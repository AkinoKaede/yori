// SPDX-License-Identifier: GPL-3.0-only

package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/signal"
	"regexp"
	"syscall"
	"time"

	"github.com/AkinoKaede/proxy-relay/config"
	"github.com/AkinoKaede/proxy-relay/datafile"
	"github.com/AkinoKaede/proxy-relay/generator"
	"github.com/AkinoKaede/proxy-relay/internal"
	"github.com/AkinoKaede/proxy-relay/server"
	"github.com/AkinoKaede/proxy-relay/subscription"
	"github.com/sagernet/sing-box/log"
	"github.com/sagernet/sing-box/option"
	E "github.com/sagernet/sing/common/exceptions"
)

const version = "1.0.0"

var (
	configPath  string
	showVersion bool
)

func init() {
	flag.StringVar(&configPath, "c", "config.yaml", "path to configuration file")
	flag.BoolVar(&showVersion, "version", false, "show version")
}

func main() {
	flag.Parse()

	if showVersion {
		fmt.Println("proxy-relay version", version)
		return
	}

	// Load configuration first to get log level
	cfg, err := config.LoadConfig(configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
		os.Exit(1)
	}

	// Setup logger with configured level
	logLevel := cfg.LogLevel
	if logLevel == "" {
		logLevel = "info"
	}
	logFactory, err := log.New(log.Options{
		Context: context.Background(),
		Options: option.LogOptions{
			Level:  logLevel,
			Output: "stdout",
		},
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create logger: %v\n", err)
		os.Exit(1)
	}
	logger := logFactory.NewLogger("proxy-relay")

	if err := run(logger, cfg); err != nil {
		logger.Error("fatal: ", err)
		os.Exit(1)
	}
}

func run(log log.ContextLogger, cfg *config.Config) error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	log.Info("Configuration loaded successfully")

	// Initialize data file for password storage
	var dataFile *datafile.DataFile
	if cfg.DataFile != "" {
		dataFile = datafile.New(ctx, cfg.DataFile)
		if err := dataFile.PreStart(); err != nil {
			return E.Cause(err, "prepare data file")
		}
		if err := dataFile.Start(); err != nil {
			return E.Cause(err, "start data file")
		}
		defer dataFile.Close()
		log.Info("data file initialized: ", cfg.DataFile)
	}

	// Initialize subscription manager
	log.Info("Initializing subscription manager with ", len(cfg.Subscriptions), " sources")
	subManager, err := subscription.NewManager(ctx, log, cfg)
	if err != nil {
		return E.Cause(err, "initialize subscription manager")
	}
	defer subManager.Close()

	// Perform initial fetch
	log.Info("Fetching all subscriptions...")
	if err := subManager.FetchAll(); err != nil {
		log.Warn("Some subscriptions failed to fetch: ", err)
	}

	// Merge outbounds
	outbounds := subManager.MergeAll()
	log.Info("Merged ", len(outbounds), " outbounds from all subscriptions")

	if len(outbounds) == 0 {
		return E.New("no outbounds available, check subscription configuration")
	}

	// Extract usernames from HTTP users
	var usernames []string
	for _, user := range cfg.HTTP.Users {
		usernames = append(usernames, user.Username)
	}

	// Generate users (one per HTTP username × outbound combination)
	users, userMapping, httpUserMapping := generator.GenerateUsers(ctx, outbounds, usernames, dataFile)
	log.Info("Generated ", len(users), " users")

	// Generate sing-box configuration
	boxConfig, err := generator.GenerateConfig(cfg, outbounds, users, userMapping)
	if err != nil {
		return E.Cause(err, "generate sing-box configuration")
	}

	// Start sing-box
	boxManager := generator.NewBoxManager()
	defer boxManager.Stop()

	log.Info("Starting sing-box with single Hysteria2 inbound on port ", cfg.Hysteria2.Port)
	if err := boxManager.Start(boxConfig); err != nil {
		return E.Cause(err, "start sing-box")
	}
	log.Info("sing-box started successfully")

	// Build HTTP server state
	var sni string
	if cfg.Hysteria2.TLS.ACME != nil && len(cfg.Hysteria2.TLS.ACME.Domain) > 0 {
		sni = cfg.Hysteria2.TLS.ACME.Domain[0]
	}

	obfsType := ""
	if cfg.Hysteria2.Obfs != nil {
		obfsType = cfg.Hysteria2.Obfs.Type
	}

	serverState := &server.State{
		Users:         users,
		LocalOnlyTags: subManager.GetLocalOnlyTags(),
		PublicAddr:    cfg.Hysteria2.Public.Server,
		PublicPorts:   cfg.Hysteria2.Public.Ports,
		SNI:           sni,
		Obfs:          obfsType,
	}

	// Start HTTP subscription server
	serverCfg := &server.ServerConfig{
		Listen: fmt.Sprintf("%s:%d", cfg.HTTP.Listen, cfg.HTTP.Port),
		Rename: cfg.HTTP.Rename,
	}
	if cfg.HTTP.TLS != nil {
		serverCfg.CertificatePath = cfg.HTTP.TLS.CertificatePath
		serverCfg.KeyPath = cfg.HTTP.TLS.KeyPath
	}

	// Compile HTTP user patterns
	for _, user := range cfg.HTTP.Users {
		var patterns []*regexp.Regexp
		for _, pattern := range user.Pattern {
			regex, err := regexp.Compile(pattern)
			if err != nil {
				log.Warn("invalid HTTP user pattern: ", pattern, ": ", err)
				continue
			}
			patterns = append(patterns, regex)
		}
		serverCfg.Users = append(serverCfg.Users, server.HTTPUser{
			Username: user.Username,
			Password: user.Password,
			Patterns: patterns,
		})
	}

	httpServer := server.NewServer(ctx, log, serverCfg)
	httpServer.UpdateState(serverState)

	if err := httpServer.Start(); err != nil {
		return E.Cause(err, "start HTTP server")
	}
	defer httpServer.Stop()

	// Setup reload mechanism
	reloadChan := make(chan struct{}, 1)
	go setupReloadTimer(cfg.ReloadInterval.Duration(), reloadChan, log)
	go setupSignalHandler(reloadChan, log)

	// Reload handler
	go func() {
		for {
			select {
			case <-reloadChan:
				log.Info("Reloading configuration...")
				if err := reload(ctx, log, cfg, subManager, boxManager, httpServer, dataFile); err != nil {
					log.Error("Reload failed: ", err)
				} else {
					log.Info("Reload completed successfully")
				}
			case <-ctx.Done():
				return
			}
		}
	}()

	// Wait for termination signal
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	<-sigChan
	log.Info("Received shutdown signal, stopping...")

	cancel()
	return nil
}

// reload performs a configuration reload
func reload(
	ctx context.Context,
	log log.ContextLogger,
	cfg *config.Config,
	subManager *subscription.Manager,
	boxManager *generator.BoxManager,
	httpServer *server.Server,
	dataFile *datafile.DataFile,
) error {
	// Fetch updated subscriptions
	if err := subManager.FetchAll(); err != nil {
		log.Warn("Some subscriptions failed to fetch: ", err)
	}

	// Merge outbounds
	outbounds := subManager.MergeAll()
	log.Info("Reloaded ", len(outbounds), " outbounds")

	if len(outbounds) == 0 {
		return E.New("no outbounds after reload")
	}

	// Extract usernames from HTTP users
	var usernames []string
	for _, user := range cfg.HTTP.Users {
		usernames = append(usernames, user.Username)
	}

	// Generate new users (one per HTTP username × outbound combination)
	users, userMapping, httpUserMapping := generator.GenerateUsers(ctx, outbounds, usernames, dataFile)
	log.Info("Generated ", len(users), " users")

	// Generate new sing-box configuration
	boxConfig, err := generator.GenerateConfig(cfg, outbounds, users, userMapping)
	if err != nil {
		return E.Cause(err, "generate configuration")
	}

	// Check if configuration actually changed
	newHash := internal.HashConfig(boxConfig)
	if boxManager.ConfigHash() == newHash {
		log.Info("Configuration unchanged, skipping sing-box restart")
		// Still update HTTP server state in case user list changed
	} else {
		// Restart sing-box only if config changed
		log.Info("Configuration changed, restarting sing-box...")
		if err := boxManager.Stop(); err != nil {
			log.Warn("Error stopping sing-box: ", err)
		}

		if err := boxManager.Start(boxConfig); err != nil {
			return E.Cause(err, "start sing-box")
		}
		log.Info("sing-box restarted successfully")
	}

	// Update HTTP server state
	var sni string
	if cfg.Hysteria2.TLS.ACME != nil && len(cfg.Hysteria2.TLS.ACME.Domain) > 0 {
		sni = cfg.Hysteria2.TLS.ACME.Domain[0]
	}

	obfsType := ""
	if cfg.Hysteria2.Obfs != nil {
		obfsType = cfg.Hysteria2.Obfs.Type
	}

	serverState := &server.State{
		Users:                     users,
		LocalOnlyTags:             subManager.GetLocalOnlyTags(),
		HTTPUserToHysteria2Users:  httpUserMapping,
		PublicAddr:                cfg.Hysteria2.Public.Server,
		PublicPorts:               cfg.Hysteria2.Public.Ports,
		SNI:                       sni,
		Obfs:                      obfsType,
	}
	httpServer.UpdateState(serverState)

	return nil
}

// setupReloadTimer creates a ticker for periodic reloads
func setupReloadTimer(interval time.Duration, reloadChan chan<- struct{}, log log.ContextLogger) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	log.Info("Reload timer set to ", interval)

	for range ticker.C {
		log.Debug("Reload timer triggered")
		select {
		case reloadChan <- struct{}{}:
		default:
			log.Warn("Reload already in progress, skipping")
		}
	}
}

// setupSignalHandler listens for SIGHUP to trigger manual reload
func setupSignalHandler(reloadChan chan<- struct{}, log log.ContextLogger) {
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGHUP)

	for range sigChan {
		log.Info("Received SIGHUP signal, triggering reload")
		select {
		case reloadChan <- struct{}{}:
		default:
			log.Warn("Reload already in progress, skipping")
		}
	}
}
